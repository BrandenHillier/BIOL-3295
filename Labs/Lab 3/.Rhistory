N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
## 3. SOLVING DIFFERENTIAL EQUATIONS
# We can also solve the equation dN/dt = r*N using the function ode() from the deSolve package
# that we loaded in at the beginning of this code. Note that dN/dt describes the change in the population
# size, N, and by "solving" the dN/dt equation we will be finding the population size, N, for different
# times.
# Parameters
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(N,t,p){
dN = 0.1*N
return(list(dN))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL)
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# Parameters
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(N,t,p){
dN = 0.1
return(list(dN))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL)
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
ExpGrowth<-function(N,t,p){
dN = 0.1*N
return(list(dN))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL)
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
ExpGrowth<-function(N,t,p){
dN = 0.1*N
return(list(dN))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL)
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(N,t,p){
dN = 0.1*N
return(list(dN))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# Parameters
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(N,t,p){
dN = 0.1*N
return(list(dN))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.1*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.1*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
rm(list=ls())
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.1*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
rm(list=ls())
require(deSolve)
# Parameters
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.1*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
rm(list=ls())
require(deSolve)
# Parameters
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.1*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
plot(out[,1],out[,2])
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
plot(out[,1],out[,2])
lines(times, N0*exp(times*.1))
# Parameters
b = 1
d = 0.9
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
# Parameters
b = 1
d = 0.99
# Initial population size
N0 = 10
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.01*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
# Parameters
b = 1
d = 0.99
# Initial population size
N0 = 11
# The times we want to calculate the solutions for.
times = seq(0,10,.1)
# The function that describes dN/dt. This function must
# return a list.
ExpGrowth<-function(y,t,p){
dy = 0.01*y
return(list(dy))
}
# Let's see what arguments are required for the ode() function.
?ode
out = ode(N0,times,ExpGrowth,p=NULL, method = "ode45")
# Note that the third argument of ExpGrowth is p, therefore, we need
# to tell R which of the numbers is b and which is d: On the left hand
# side of the ='s we are specifying the name "b" and on the right hand
# side we are supplying the numerical value b = 0.9.
c(b=b,d=d)
head(out)
# Let's plot our output (the ode helpful gives examples of how to do this too)
plot(out[,1], out[,2], xlab = "time", ylab = "population size", typ="l")
lines(times, N0*exp((b-d)*times), col="red")
# We note that geometric growth (discrete time) gives very close predictions to
# exponential growth when exp(r) = lambda.
# Now let's test this.
lambda = exp(0.1)
# Let's slightly modify the old geometric growth function so that
# lambda can be supplied as an argument without requiring b and d.
GeoGrowth.lambda = function(Nstart,lambda,tstart,tend){
N=NULL
Time=NULL
N[1]=Nstart
Time[1]=tstart
for(t in seq(1,tend-tstart,1)){
N[t+1] = lambda*N[t]
Time[t+1] = tstart+t
}
Popn.Size = data.frame(time = Time, Popn.Size = N)
return(Popn.Size)
}
DT = GeoGrowth.lambda(N0,lambda,0,10)
head(DT)
# To add points to an existing plot use:
points(DT$time, DT$Popn.Size)
5*25*(75/100)
5*95*(5/100)
5*99*(1/100)
5*70*(30/100)
